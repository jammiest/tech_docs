# 模逆元

### **模逆元（Modular Inverse）详解**
模逆元是密码学、算法设计和数学计算中的核心概念，尤其在 **RSA加密、快速幂取模、中国剩余定理** 等场景中至关重要。下面从定义、计算方法到代码实现全面解析。

---

## **1. 什么是模逆元？**
在模运算中，若整数 \( a \) 和 \( m \) 互质（即 \( \gcd(a, m) = 1 \)），则存在唯一整数 \( x \) 使得：
\[
a \cdot x \equiv 1 \pmod{m}
\]
称 \( x \) 为 \( a \) 在模 \( m \) 下的逆元，记作 \( a^{-1} \)。

**示例**  
求 \( 3 \) 在模 \( 11 \) 下的逆元：  
\( 3 \cdot x \equiv 1 \pmod{11} \) → \( x = 4 \)（因为 \( 3 \times 4 = 12 \equiv 1 \pmod{11} \)）

---

## **2. 计算方法**
### **（1）暴力枚举法（仅适用于小模数）**
遍历 \( x \) 从 \( 1 \) 到 \( m-1 \)，验证 \( a \cdot x \mod m = 1 \)。

**时间复杂度**：\( O(m) \)（效率低）

### **（2）扩展欧几里得算法（最优解法）**
利用扩展欧几里得算法（Extended Euclidean Algorithm）求解方程 \( a \cdot x + m \cdot y = 1 \)，得到的 \( x \) 即为模逆元。

**算法步骤**：
1. 用欧几里得算法求 \( \gcd(a, m) \)，若非 1 则逆元不存在。
2. 反向递推求解 \( x \) 和 \( y \)。

**Python实现**：
```python
def extended_gcd(a, b):
    if b == 0:
        return a, 1, 0
    gcd, x1, y1 = extended_gcd(b, a % b)
    x = y1
    y = x1 - (a // b) * y1
    return gcd, x, y

def mod_inverse(a, m):
    gcd, x, _ = extended_gcd(a, m)
    if gcd != 1:
        return None  # 逆元不存在
    return x % m  # 保证结果为正

print(mod_inverse(3, 11))  # 输出 4
```

**时间复杂度**：\( O(\log \min(a, m)) \)

### **（3）费马小定理（适用于模数为质数）**
若 \( m \) 是质数且 \( a \) 不是 \( m \) 的倍数，则：
\[
a^{m-1} \equiv 1 \pmod{m} \implies a^{-1} \equiv a^{m-2} \pmod{m}
\]
通过快速幂计算 \( a^{m-2} \mod m \)。

**Python实现**：
```python
def mod_inverse_fermat(a, m):
    return pow(a, m - 2, m)

print(mod_inverse_fermat(3, 11))  # 输出 4
```

**适用条件**：\( m \) 为质数（如 RSA 中的模数）  
**时间复杂度**：\( O(\log m) \)

---

## **3. 实际应用场景**
### **（1）RSA 加密/解密**
- 公钥 \( e \) 和私钥 \( d \) 满足 \( e \cdot d \equiv 1 \pmod{\phi(n)} \)，其中 \( \phi(n) \) 是欧拉函数。
- 私钥 \( d \) 本质是 \( e \) 的模逆元。

### **（2）组合数取模（Lucas定理）**
计算 \( C(n, k) \mod p \) 时，需要预处理阶乘的模逆元：
\[
C(n, k) = \frac{n!}{k!(n-k)!} \mod p
\]

### **（3）中国剩余定理（CRT）**
求解同余方程组时，需要计算模数的逆元。

---

## **4. 常见问题**
### **Q1：逆元一定存在吗？**
仅当 \( \gcd(a, m) = 1 \) 时存在，否则无解（如 \( a = 2 \), \( m = 4 \) 时无逆元）。

### **Q2：如何批量计算逆元？**
线性递推法（适用于质数模数 \( p \)）：
```python
inv[1] = 1
for i in range(2, p):
    inv[i] = (p - p // i) * inv[p % i] % p
```

### **Q3：负数的模逆元如何处理？**
结果取正：若 \( x \) 是逆元，则 \( x \mod m \) 为正（如 Python 中 `x % m`）。

---

## **5. 代码实战**
**任务**：计算 \( \frac{a}{b} \mod m \)（除法转乘法）  
**解法**：先求 \( b^{-1} \mod m \)，再计算 \( a \cdot b^{-1} \mod m \)。

```python
def div_mod(a, b, m):
    inv_b = mod_inverse(b, m)
    if inv_b is None:
        raise ValueError("b has no inverse mod m")
    return (a * inv_b) % m

print(div_mod(7, 3, 11))  # 7/3 ≡ 7*4 ≡ 28 ≡ 6 (mod 11)
```

---

## **总结**
- **核心用途**：将模运算中的除法转为乘法。
- **最优算法**：扩展欧几里得（通用）、费马小定理（模数为质数）。
- **高频场景**：密码学、组合数学、算法竞赛。

掌握模逆元能显著提升在数论相关编程问题中的解决能力。