# 数据结构与算法概论

## 数据结构

### 常用数据结构对比表

| 数据结构   | 描述                         | 核心操作时间复杂度                | 特点                             | 典型应用场景         |
| ---------- | ---------------------------- | --------------------------------- | -------------------------------- | -------------------- |
| **数组**   | 连续内存存储的线性结构       | - 访问：O(1)<br>- 插入/删除：O(n) | 固定大小、内存紧凑、缓存友好     | 矩阵运算、数据缓存   |
| **链表**   | 通过指针连接的节点序列       | - 访问：O(n)<br>- 插入/删除：O(1) | 动态扩容、内存分散、支持高效增删 | LRU缓存、多项式运算  |
| **栈**     | LIFO（后进先出）结构         | - 所有操作：O(1)                  | 单端操作、递归调用实现           | 函数调用栈、括号匹配 |
| **队列**   | FIFO（先进先出）结构         | - 基本操作：O(1)                  | 双端操作、循环队列优化           | BFS算法、消息队列    |
| **哈希表** | 键值对存储，通过哈希函数定位 | - 平均：O(1)<br>- 最坏：O(n)      | 冲突处理（开放寻址/链地址法）    | 字典、缓存系统       |
| **二叉树** | 每个节点最多两个子节点       | - 操作：O(logn)~O(n)              | 中序/前序/后序遍历               | 文件系统、二叉搜索树 |
| **堆**     | 完全二叉树，满足堆序性质     | - 插入/删除：O(logn)              | 快速获取最值、优先级管理         | 优先级队列、TopK问题 |
| **图**     | 顶点和边的集合               | 依算法而定                        | 邻接矩阵/邻接表存储              | 社交网络、路径规划   |
| **Trie树** | 前缀树，共享公共前缀         | - 插入/查询：O(k)（k为键长）      | 空间换时间、适合字符串检索       | 输入法词库、IP路由   |
| **跳表**   | 多层索引的有序链表           | - 平均：O(logn)                   | 概率性平衡、替代平衡树的简单方案 | Redis有序集合        |

### 复杂度速查表

| 操作     | 数组 | 链表 | 哈希表 | 二叉搜索树（平衡） | 堆      |
| -------- | ---- | ---- | ------ | ------------------ | ------- |
| **访问** | O(1) | O(n) | O(1)*  | O(logn)            | O(1)    |
| **插入** | O(n) | O(1) | O(1)*  | O(logn)            | O(logn) |
| **删除** | O(n) | O(1) | O(1)*  | O(logn)            | O(logn) |
| **搜索** | O(n) | O(n) | O(1)*  | O(logn)            | O(n)    |

> *注：哈希表的时间复杂度为平均情况，最坏情况下可能退化为O(n)

## 算法

### 常用算法对比表

| 算法类别     | 核心思想                 | 时间复杂度     | 空间复杂度 | 经典应用场景           |
| ------------ | ------------------------ | -------------- | ---------- | ---------------------- |
| **排序算法** |                          |                |            |                        |
| 冒泡排序     | 相邻元素两两比较交换     | O(n²)          | O(1)       | 教学示例               |
| 快速排序     | 分治法，选取基准值分区   | 平均O(nlogn)   | O(logn)    | 大规模数据排序         |
| 归并排序     | 分治法，先分后合         | O(nlogn)       | O(n)       | 外部排序、链表排序     |
| 堆排序       | 利用堆结构排序           | O(nlogn)       | O(1)       | TopK问题               |
| **查找算法** |                          |                |            |                        |
| 顺序查找     | 逐个比较                 | O(n)           | O(1)       | 无序数据查找           |
| 二分查找     | 每次比较将搜索范围减半   | O(logn)        | O(1)       | 有序数据查找           |
| 哈希查找     | 通过哈希函数直接定位     | O(1)           | O(n)       | 字典、缓存系统         |
| **图算法**   |                          |                |            |                        |
| DFS          | 深度优先，递归/栈实现    | O(V+E)         | O(V)       | 拓扑排序、连通分量     |
| BFS          | 广度优先，队列实现       | O(V+E)         | O(V)       | 最短路径（无权图）     |
| Dijkstra     | 贪心策略，优先队列       | O(E+VlogV)     | O(V)       | 单源最短路径（无负权） |
| Floyd        | 动态规划，三重循环       | O(V³)          | O(V²)      | 多源最短路径           |
| **其他算法** |                          |                |            |                        |
| 动态规划     | 记忆化搜索，状态转移方程 | 问题相关       | 问题相关   | 背包问题、编辑距离     |
| 贪心算法     | 局部最优选择             | 通常多项式时间 | 通常O(1)   | 霍夫曼编码、任务调度   |
| 分治算法     | 分解→解决→合并           | 通常O(nlogn)   | 递归栈空间 | 归并排序、快速排序     |
| 回溯算法     | 试探+回溯                | 通常指数级     | 递归栈空间 | N皇后、组合问题        |
| KMP          | 模式匹配，利用部分匹配表 | O(m+n)         | O(m)       | 文本编辑器搜索         |

### 排序算法详细对比

| 排序算法 | 稳定性 | 原地排序 | 最好情况 | 最坏情况 | 平均情况 |
| -------- | ------ | -------- | -------- | -------- | -------- |
| 冒泡排序 | 稳定   | 是       | O(n)     | O(n²)    | O(n²)    |
| 快速排序 | 不稳定 | 是       | O(nlogn) | O(n²)    | O(nlogn) |
| 归并排序 | 稳定   | 否       | O(nlogn) | O(nlogn) | O(nlogn) |
| 堆排序   | 不稳定 | 是       | O(nlogn) | O(nlogn) | O(nlogn) |
| 插入排序 | 稳定   | 是       | O(n)     | O(n²)    | O(n²)    |


表格说明：
复杂度表示：

-`V`：图的顶点数
-`E`：图的边数
-`n`：数据规模
-`m`：模式串长度

关键特性标注：

- 稳定性：相等元素排序后相对位置不变
- 原地排序：是否只需要O(1)额外空间

典型应用场景：

- 快速排序：Python的sorted()实现
- 归并排序：大数据外排序、Git的merge操作
- Dijkstra：地图导航路径规划

## 算法选择指南

1. **小规模数据**（n < 100）：
   - 优先考虑实现简单的冒泡/插入排序

2. **通用排序**：
   - 需要稳定性 → 归并排序
   - 需要原地排序 → 快速排序

3. **查找场景**：
   - 静态数据 → 二分查找（需预先排序）
   - 动态数据 → 哈希表/二叉搜索树

4. **图问题**：
   - 无权图最短路径 → BFS
   - 带权图最短路径 → Dijkstra（无负权）/ Bellman-Ford（有负权）