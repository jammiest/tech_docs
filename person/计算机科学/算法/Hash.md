# 散列表

### **散列表（Hash Table）详解**

散列表（**Hash Table**，又称哈希表）是一种基于**键值对（Key-Value）**存储的高效数据结构，它通过**散列函数（Hash Function）**将键（Key）映射到表中的特定位置，从而实现平均时间复杂度接近 **O(1)** 的快速查找、插入和删除操作。

---

## **1. 核心概念**
### **1.1 散列函数（Hash Function）**
- **作用**：将任意大小的键（如字符串、对象）转换为固定大小的整数（即**哈希值**），作为数组的索引。
- **理想特性**：
  - **确定性**：同一键始终生成相同的哈希值。
  - **均匀性**：哈希值应均匀分布，减少冲突。
  - **高效性**：计算速度快。
- **常见散列函数**：
  - 除法取余法：`hash(key) = key % table_size`
  - 乘法取整法、MD5/SHA（用于加密场景）。

### **1.2 哈希冲突（Collision）**
当不同键映射到同一索引时发生冲突。解决方法：
1. **开放寻址法（Open Addressing）**：
   - 线性探测：冲突后顺序查找下一个空槽。
   - 二次探测：按平方步长跳跃查找。
   - 双重散列：使用第二个散列函数计算步长。
2. **链地址法（Separate Chaining）**：
   - 每个槽位存储一个链表（或红黑树），冲突键追加到链表。

---

## **2. 操作与时间复杂度**
| 操作       | 平均时间复杂度 | 最坏情况       |
|------------|----------------|----------------|
| 插入（Put） | O(1)           | O(n)（全冲突） |
| 查找（Get） | O(1)           | O(n)           |
| 删除（Remove）| O(1)          | O(n)           |

> **注**：最坏情况发生在所有键冲突且使用低效冲突解决策略时。

---

## **3. 关键问题与优化**
### **3.1 负载因子（Load Factor）**
- 定义：`负载因子 = 元素数量 / 散列表容量`。
- **阈值**：通常设定为 0.75（Java HashMap），超过时触发**扩容（Rehashing）**：
  1. 新建更大的数组（如双倍扩容）。
  2. 重新计算所有键的哈希值并迁移数据。

### **3.2 散列函数设计**
- **避免聚集**：如线性探测易导致“聚集现象”，需优化探测策略。
- **加密哈希**：如SHA-256适用于安全场景，但计算成本高。

### **3.3 动态扩容与缩容**
- **扩容**：避免频繁冲突导致性能下降。
- **缩容**：删除大量元素后释放空间（如Redis哈希表）。

---

## **4. 实际应用**
1. **数据库索引**：如MySQL的哈希索引。
2. **缓存系统**：Redis、Memcached的核心数据结构。
3. **语言内置类型**：
   - Python字典（`dict`）、Java `HashMap`、C++ `unordered_map`。
4. **去重与计数**：如统计词频（`WordCount`）。

---

## **5. 代码示例（Python）**
```python
# 使用Python字典（基于散列表实现）
hash_table = {}
hash_table["apple"] = 1    # 插入
hash_table["banana"] = 2
print(hash_table.get("apple"))  # 查找，输出1

# 手动实现简单散列表（链地址法）
class HashTable:
    def __init__(self, size):
        self.size = size
        self.table = [[] for _ in range(size)]  # 每个槽位是链表

    def _hash(self, key):
        return hash(key) % self.size  # Python内置hash函数

    def put(self, key, value):
        idx = self._hash(key)
        for item in self.table[idx]:  # 遍历链表处理冲突
            if item[0] == key:
                item[1] = value  # 更新现有键
                return
        self.table[idx].append([key, value])  # 新增键值对

    def get(self, key):
        idx = self._hash(key)
        for item in self.table[idx]:
            if item[0] == key:
                return item[1]
        raise KeyError(f"Key {key} not found")
```

---

## **6. 散列表 vs. 其他数据结构**
| 特性               | 散列表          | 平衡二叉搜索树（如红黑树） |
|--------------------|----------------|----------------------------|
| **平均时间复杂度** | O(1)           | O(log n)                   |
| **有序性**         | 无             | 按键有序                   |
| **内存占用**       | 较低（数组+链表）| 较高（节点指针）           |
| **适用场景**       | 快速查找、缓存  | 范围查询、有序遍历         |

---

## **7. 常见面试问题**
1. **如何解决哈希冲突？**  
   （回答链地址法或开放寻址法的优缺点）
2. **HashMap的扩容机制是怎样的？**  
   （解释负载因子和再散列过程）
3. **为什么哈希表的时间复杂度是O(1)？**  
   （理想情况下无冲突，直接通过索引访问）

---

## **总结**
散列表通过巧妙的**空间换时间**策略，成为高效键值存储的基石。理解其冲突解决、扩容机制及散列函数设计，是优化实际应用（如数据库、缓存）的关键。学习时建议手动实现一个简单版本，加深对底层逻辑的理解。