# 设计模式速查手册

## 🎯 创建型模式 (Creational Patterns)

### 1. 单例模式 (Singleton)
**核心思想**：确保一个类只有一个实例，并提供全局访问点。
**适用场景**：
- 需要严格控制全局唯一实例的场景
- 频繁使用的对象（如配置管理器、日志记录器）
- 资源共享的场景（如线程池、数据库连接池）
**优点**：减少内存开销，避免重复创建
**缺点**：难以测试，可能隐藏过度耦合

### 2. 工厂方法模式 (Factory Method)
**核心思想**：定义一个创建对象的接口，但让子类决定实例化哪个类。
**适用场景**：
- 无法预知需要创建的对象的具体类型
- 希望将对象的创建与使用分离
- 需要为不同的上下文提供不同的对象实现
**优点**：符合开闭原则，代码可扩展性好
**缺点**：需要创建大量子类，增加系统复杂度

### 3. 抽象工厂模式 (Abstract Factory)
**核心思想**：提供一个接口，用于创建相关或依赖对象的家族，而不需要指定具体类。
**适用场景**：
- 需要创建一系列相关或依赖的对象
- 系统需要独立于其产品的创建、组合和表示
- 需要确保产品之间的兼容性
**优点**：保证产品族的兼容性，易于交换产品系列
**缺点**：难以支持新种类的产品

### 4. 建造者模式 (Builder)
**核心思想**：将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。
**适用场景**：
- 创建复杂对象，其组成部分的构建顺序是固定的
- 需要创建不同表示的对象
- 希望将对象的构建过程隐藏起来
**优点**：封装性好，构建过程可控，可以构造复杂对象
**缺点**：产品必须有共同点，适用范围有限

### 5. 原型模式 (Prototype)
**核心思想**：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
**适用场景**：
- 需要创建的对象成本较高（如初始化需要大量资源）
- 希望避免使用类的层次结构来创建对象
- 需要动态配置对象的类型
**优点**：性能优化，避免重复初始化
**缺点**：需要实现克隆方法，深拷贝实现复杂

## 🏗️ 结构型模式 (Structural Patterns)

### 6. 适配器模式 (Adapter)
**核心思想**：将一个类的接口转换成客户希望的另外一个接口。
**适用场景**：
- 需要使用现有的类，但其接口不符合要求
- 想要创建一个可以重用的类，与不相关的类协同工作
- 需要多个子类，但只通过接口匹配每个子类不现实
**优点**：让原本接口不兼容的类可以协同工作
**缺点**：过多使用会使系统变得凌乱

### 7. 桥接模式 (Bridge)
**核心思想**：将抽象部分与它的实现部分分离，使它们都可以独立地变化。
**适用场景**：
- 需要在抽象和实现之间建立更松散的联系
- 抽象和实现都需要通过子类化来扩展
- 需要避免抽象和实现之间的永久绑定
**优点**：分离接口及其实现，提高可扩展性
**缺点**：增加了系统的理解和设计难度

### 8. 组合模式 (Composite)
**核心思想**：将对象组合成树形结构以表示"部分-整体"的层次结构。
**适用场景**：
- 需要表示对象的部分-整体层次结构
- 希望用户忽略组合对象与单个对象的不同
- 结构中可以包含个体对象和组合对象
**优点**：简化客户端代码，容易增加新类型的组件
**缺点**：设计较抽象，很难限制组合中的组件

### 9. 装饰器模式 (Decorator)
**核心思想**：动态地给一个对象添加一些额外的职责。
**适用场景**：
- 需要在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责
- 需要扩展一个类的功能，但不能使用子类进行扩展
- 需要撤销职责
**优点**：比继承更灵活，可以动态添加或删除功能
**缺点**：会产生很多小对象，增加系统复杂度

### 10. 外观模式 (Facade)
**核心思想**：为子系统中的一组接口提供一个一致的界面。
**适用场景**：
- 需要为复杂的子系统提供一个简单的接口
- 客户端与抽象类的实现部分之间存在很大的依赖性
- 需要构建一个层次结构的子系统
**优点**：减少系统相互依赖，提高灵活性
**缺点**：不符合开闭原则，修改较麻烦

### 11. 享元模式 (Flyweight)
**核心思想**：运用共享技术有效地支持大量细粒度的对象。
**适用场景**：
- 一个应用程序使用了大量的对象
- 由于使用大量对象，造成很大的存储开销
- 对象的大多数状态都可以变为外部状态
**优点**：大幅度降低内存中对象的数量
**缺点**：提高了系统复杂度，需要分离外部状态

### 12. 代理模式 (Proxy)
**核心思想**：为其他对象提供一种代理以控制对这个对象的访问。
**适用场景**：
- 需要远程代理（为不同地址空间的对象提供本地代表）
- 需要虚拟代理（根据需要创建开销很大的对象）
- 需要安全代理（控制对原始对象的访问）
**优点**：在客户端和目标对象之间起到中介作用
**缺点**：可能会造成请求处理速度变慢

## 🎭 行为型模式 (Behavioral Patterns)

### 13. 责任链模式 (Chain of Responsibility)
**核心思想**：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。
**适用场景**：
- 有多个对象可以处理一个请求，哪个对象处理该请求在运行时自动确定
- 想在不明确指定接收者的情况下，向多个对象中的一个提交请求
- 可处理一个请求的对象集合应被动态指定
**优点**：降低耦合度，增强了给对象指派职责的灵活性
**缺点**：请求可能得不到处理，性能受影响

### 14. 命令模式 (Command)
**核心思想**：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化。
**适用场景**：
- 需要将请求调用者和请求接收者解耦
- 需要在不同的时间指定请求、将请求排队或执行请求
- 需要支持撤销操作
**优点**：解耦请求发送者和接收者，支持撤销和重做
**缺点**：可能产生大量的具体命令类

### 15. 解释器模式 (Interpreter)
**核心思想**：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
**适用场景**：
- 当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象语法树
- 该文法简单（对于复杂的文法，文法的类层次变得庞大而无法管理）
- 效率不是一个关键问题
**优点**：易于改变和扩展文法
**缺点**：执行效率较低，复杂的文法难以维护

### 16. 迭代器模式 (Iterator)
**核心思想**：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。
**适用场景**：
- 需要访问一个聚合对象的内容而无需暴露它的内部表示
- 需要支持对聚合对象的多种遍历
- 需要为遍历不同的聚合结构提供一个统一的接口
**优点**：支持多种遍历方式，简化了聚合类的接口
**缺点**：增加了系统的复杂性

### 17. 中介者模式 (Mediator)
**核心思想**：用一个中介对象来封装一系列的对象交互。
**适用场景**：
- 一组对象以定义良好但是复杂的方式进行通信
- 想定制一个分布在多个类中的行为，而又不想生成太多的子类
- 对象组之间的通信关系错综复杂
**优点**：减少了类之间的耦合，简化了对象协议
**缺点**：中介者可能会变得过于复杂

### 18. 备忘录模式 (Memento)
**核心思想**：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
**适用场景**：
- 必须保存一个对象在某一个时刻的状态，这样以后需要时它才能恢复到先前的状态
- 如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性
**优点**：保持封装边界，简化了原发器
**缺点**：可能代价很高，管理者可能需要存储大量备忘录

### 19. 观察者模式 (Observer)
**核心思想**：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
**适用场景**：
- 当一个抽象模型有两个方面，其中一个方面依赖于另一个方面
- 当对一个对象的改变需要同时改变其它对象，而不知道具体有多少对象有待改变
- 当一个对象必须通知其它对象，而它又不能假定其它对象是谁
**优点**：支持广播通信，实现了抽象耦合
**缺点**：可能引起不必要的更新

### 20. 状态模式 (State)
**核心思想**：允许一个对象在其内部状态改变时改变它的行为。
**适用场景**：
- 一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为
- 一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态
**优点**：将与特定状态相关的行为局部化，并且将不同状态的行为分割开来
**缺点**：导致较多的具体状态类

### 21. 策略模式 (Strategy)
**核心思想**：定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。
**适用场景**：
- 许多相关的类仅仅是行为有异
- 需要使用一个算法的不同变体
- 算法使用客户不应该知道的数据
- 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现
**优点**：提供了管理相关的算法族的办法，支持开闭原则
**缺点**：客户端必须知道所有的策略类

### 22. 模板方法模式 (Template Method)
**核心思想**：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。
**适用场景**：
- 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现
- 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复
- 控制子类扩展
**优点**：提高代码复用性，实现了反向控制
**缺点**：每个不同的实现都需要定义一个子类

### 23. 访问者模式 (Visitor)
**核心思想**：表示一个作用于某对象结构中的各元素的操作。
**适用场景**：
- 一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作
- 需要对一个对象结构中的对象进行很多不同的并且不相关的操作
- 定义对象结构的类很少改变，但经常需要在此结构上定义新的操作
**优点**：增加新的操作很容易，将相关行为集中在一个访问者对象中
**缺点**：增加新的元素类很困难，破坏了封装性

## 📊 设计模式选择指南

### 按问题类型选择模式
| 问题类型 | 推荐模式 | 替代模式 |
|---------|---------|---------|
| 创建复杂对象 | 建造者模式 | 抽象工厂模式 |
| 需要全局唯一实例 | 单例模式 | - |
| 创建相关对象族 | 抽象工厂模式 | 工厂方法模式 |
| 避免创建成本高 | 原型模式 | - |
| 接口不兼容 | 适配器模式 | 外观模式 |
| 分离抽象与实现 | 桥接模式 | 适配器模式 |
| 部分-整体结构 | 组合模式 | - |
| 动态添加功能 | 装饰器模式 | 适配器模式 |
| 简化复杂系统 | 外观模式 | 中介者模式 |
| 大量细粒度对象 | 享元模式 | 单例模式 |
| 控制对象访问 | 代理模式 | 装饰器模式 |

### 设计原则总结
1. **开闭原则**：对扩展开放，对修改关闭
2. **单一职责**：一个类只负责一个功能领域
3. **里氏替换**：子类必须能够替换父类
4. **依赖倒置**：依赖于抽象而不是具体实现
5. **接口隔离**：使用多个专门的接口
6. **迪米特法则**：最少知识原则，减少对象间依赖
7. **合成复用**：优先使用对象组合而不是继承

这个速查表提供了23种设计模式的核心概念、适用场景和优缺点，帮助你在软件设计过程中快速选择合适的设计模式。