# 条件判断及运算符

## if语句

> 官方文档(if is Evil)：<https://www.nginx.com/resources/wiki/start/topics/depth/ifisevil/>  
> 官方文档：<https://nginx.org/en/docs/http/ngx_http_rewrite_module.html#return>  
> 中文博客: <https://tyloafer.github.io/posts/211/>

!> 当在location区块中使用 if 指令的时候会有一些问题, 在某些情况下它并不按照你的预期运行而是做一些完全不同的事情. 而在另一些情况下他甚至会出现段错误. 一般来说避免使用 if 指令是个好主意.

在location区块里if指令下唯一100%安全的指令应该只有:

> return …;  
> rewrite … last;

除此以外的指令都可能导致不可预期的行为, 包括诡异的发出段错误信号(SIGSEGV).

要着重注意的是if的行为不是反复无常的, 给出两个条件完全一致的请求, Nginx并不会出现一个正常工作而一个请求失败的随机情况, 在明晰的测试和理解下 if 是完全可用的. 尽管如此, 在这里还是建议使用其他指令.

总有一些情况你无法避免去使用 if 指令, 比如你需要测试一个变量, 而它没有相应的配置指令.

```nginx
if ($request_method = POST) {
  return 405;
}
if ($args ~ post=140){
  rewrite ^ http://example.com/ permanent;
}
```

**如何替换掉if**

使用 `try_files` 如果他适合你的需求. 在其他的情况下使用 `return …` 或者 `rewrite … last`。 还有一些情况可能要把 if 移动到 server 区块下(只有当其他的rewrite模块指令也允许放在的地方才是安全的).

如下可以安全地改变用于处理请求的 location。

```nginx
location / {
    error_page 418 = @other;
    recursive_error_pages on;

    if ($something) {
        return 418;
    }

    # some configuration
    ...
}

location @other {
    # some other configuration
    ...
}
```

在某些情况下使用嵌入脚本模块(嵌入perl或者其他一些第三方模块)处理这些脚本更佳.

**例子**

!> 以下是一些例子用来解释为什么if是邪恶的. 非专业人事指, 请勿模仿!

```nginx
# 这里收集了一些出人意料的坑爹配置来展示 location 中的 if 指令是万恶的

# 只有第二个 header 才会在响应中展示
# 这不是Bug, 只是他的处理流程如此
location /only-one-if {
    set $true 1;

    if ($true) {
        add_header X-First 1;
    }

    if ($true) {
        add_header X-Second 2;
    }

    return 204;
}

# 因为if, 请求会在未改变uri的情况下下发送到后台的 '/'

location /proxy-pass-uri {
    proxy_pass http://127.0.0.1:8080/;

    set $true 1;

    if ($true) {
        # nothing
    }
}

# 因为if, try_files 失效

location /if-try-files {
        try_files  /file  @fallback;

        set $true 1;

        if ($true) {
            # nothing
        }
}

# nginx 将会发出段错误信号(SIGSEGV)

location /crash {

    set $true 1;

    if ($true) {
        # fastcgi_pass here
        fastcgi_pass  127.0.0.1:9000;
    }

    if ($true) {
        # no handler here
    }
}

# alias with captures isn't correcly inherited into implicit nested location created by if
# alias with captures 不能正确的继承到由if创建的隐式嵌入的location 

location ~* ^/if-and-alias/(?<file>.*) {
    alias /tmp/$file;

    set $true 1;

    if ($true) {
        # nothing
    }
}
```

**为什么会这样且到现在都没修复这些问题?**

if 指令是 rewrite 模块中的一部分, 是实时生效的指令.另一方面来说, nginx 配置大体上是陈述式的.在某些时候用户出于特殊是需求的尝试, 会在if里写入一些非rewrite指令, 这直接导致了我们现处的情况. 大多数情况下他可以工作, 但是…看看上面.  
看起来唯一正确的修复方式是完全禁用if中的非rewrite指令. 但是这将破坏很多现有可用的配置, 所以还没有修复.

### if语法

| key     | value                  |
| ------- | ---------------------- |
| 语法:   | if (condition) { ... } |
| 默认值: | —                      |
| 上下文: | server, location       |

### if条件

| 条件       | 描述                                                                                                                         |
| ---------- | ---------------------------------------------------------------------------------------------------------------------------- |
| 变量名     | 如果变量值为空或者是以`0`开始的字符串，则条件为假                                                                            |
| `=`,`!=`   | 比较变量和字符串                                                                                                             |
| `~`,`~*`   | 匹配变量和正则。正则可以包含匹配组，可以使用变量$1..$9引用。如果正则中包含`}`或者`;`，整个表达式应该被包含在单引号或双引号中 |
| `-f`,`!-f` | 检查文件是否存在                                                                                                             |
| `-d`,`!-d` | 检查目录是否存在                                                                                                             |
| `-e`,`!-e` | 检查文件、目录或符号链接是否存在                                                                                             |
| `-x`,`!-x` | 检查可执行文件                                                                                                               |