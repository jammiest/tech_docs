# 散列表

散列表又称为散列映射，映射，字典，关联数组

## 原理以及概念

键-->散列函数（映射）-->值

`y=f(x) , y ∈ S`

` a=b => f(a)=f(b)`

**键**：理论上取值不限，暂时记作x  
**值**：已知范围的值，本质是用于存放该键相关内容的散列表的位置，暂时记为y  
**散列表**：映射后的值所有可能的落点，记为S，  
**散列函数**：将无限范围的键映射到有限范围的值，且相同键名映射到值一样，记为f(x)  
**冲突**：不同的键映射到相同的值时就发生了冲突，冲突常见解决方法是，在冲突的散列表后面创建链表保存冲突的数据  
**填充因子**：等于`散列表包含的元素个数`/`位置长度`，范围为大于0的数，举例如下：
- 待填充数据100个，散列表有200个位置，填充因子为 100/200 = 0.5
- 待填充数据100个，散列表有100个位置，填充因子为 100/100 = 1
- 待填充数据100个，散列表有40个位置，填充因子为 100/40 = 2.5

## 常见的散列算法

`md5`,`sha1`,`sha265`,`sha512`

## 应用

- 快速查找
- 缓存：`Redis`
- DNS解析

## 性能

散列表的性能与位置多少无关，在不存在冲突的情况下，查改删操作，位置大小为100和位置大小为100亿所花的时间理论上都是一样的  
无冲突情况下，散列表拥有良好的性能，冲突概率较高时将变为链表操作，性能急剧下降

1、时间复杂度

| 操作 | 平均情况 | 最差情况 |
| ---- | -------- | -------- |
| 查找 | O(1)     | O(n)     |
| 插入 | O(1)     | O(n)     |
| 删除 | O(1)     | O(n)     |

2、影响影响性能因素

散列表要保持良好的性能，就要尽可能的避免冲突

- 较低的填充因子（经验总结最佳为小于`0.7`）
- 良好的散列函数